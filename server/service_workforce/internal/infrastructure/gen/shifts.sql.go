// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: shifts.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createShift = `-- name: CreateShift :one
INSERT INTO work_shifts (
  company_id, name, description, start_time, end_time,
  break_duration_minutes, grace_period_minutes, early_departure_minutes,
  work_days, is_active
) VALUES (
    $1, $2, $3, $4, $5,
    $6, $7, $8,
    $9, TRUE
)
RETURNING shift_id
`

type CreateShiftParams struct {
	CompanyID             pgtype.UUID
	Name                  string
	Description           pgtype.Text
	StartTime             pgtype.Time
	EndTime               pgtype.Time
	BreakDurationMinutes  pgtype.Int4
	GracePeriodMinutes    pgtype.Int4
	EarlyDepartureMinutes pgtype.Int4
	WorkDays              []int32
}

func (q *Queries) CreateShift(ctx context.Context, arg CreateShiftParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createShift,
		arg.CompanyID,
		arg.Name,
		arg.Description,
		arg.StartTime,
		arg.EndTime,
		arg.BreakDurationMinutes,
		arg.GracePeriodMinutes,
		arg.EarlyDepartureMinutes,
		arg.WorkDays,
	)
	var shift_id pgtype.UUID
	err := row.Scan(&shift_id)
	return shift_id, err
}

const deleteShift = `-- name: DeleteShift :exec
DELETE FROM work_shifts
WHERE shift_id = $1
`

func (q *Queries) DeleteShift(ctx context.Context, shiftID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteShift, shiftID)
	return err
}

const disableShiftWithId = `-- name: DisableShiftWithId :exec
UPDATE work_shifts
SET is_active = FALSE,
    updated_at = now()
WHERE shift_id = $1 and company_id = $2
`

type DisableShiftWithIdParams struct {
	ShiftID   pgtype.UUID
	CompanyID pgtype.UUID
}

func (q *Queries) DisableShiftWithId(ctx context.Context, arg DisableShiftWithIdParams) error {
	_, err := q.db.Exec(ctx, disableShiftWithId, arg.ShiftID, arg.CompanyID)
	return err
}

const enableShiftWithId = `-- name: EnableShiftWithId :exec
UPDATE work_shifts
SET is_active = TRUE,
    updated_at = now()
WHERE shift_id = $1 and company_id = $2
`

type EnableShiftWithIdParams struct {
	ShiftID   pgtype.UUID
	CompanyID pgtype.UUID
}

func (q *Queries) EnableShiftWithId(ctx context.Context, arg EnableShiftWithIdParams) error {
	_, err := q.db.Exec(ctx, enableShiftWithId, arg.ShiftID, arg.CompanyID)
	return err
}

const getInfoEmployeeInShift = `-- name: GetInfoEmployeeInShift :many
SELECT 
    e.employee_id,
    e.employee_code,
    u.full_name,
    CASE 
        WHEN es.shift_id = $2 THEN TRUE 
        ELSE FALSE 
    END AS current_shift,
    ws.name AS shift_active
FROM employees e
INNER JOIN users u ON e.employee_id = u.user_id
LEFT JOIN employee_shifts es ON e.employee_id = es.employee_id 
    AND es.is_active = TRUE
    AND es.effective_from <= CURRENT_DATE 
    AND (es.effective_to IS NULL OR es.effective_to >= CURRENT_DATE)
LEFT JOIN work_shifts ws ON es.shift_id = ws.shift_id
WHERE e.company_id = $1
ORDER BY e.employee_code
`

type GetInfoEmployeeInShiftParams struct {
	CompanyID pgtype.UUID
	ShiftID   pgtype.UUID
}

type GetInfoEmployeeInShiftRow struct {
	EmployeeID   pgtype.UUID
	EmployeeCode string
	FullName     string
	CurrentShift bool
	ShiftActive  pgtype.Text
}

func (q *Queries) GetInfoEmployeeInShift(ctx context.Context, arg GetInfoEmployeeInShiftParams) ([]GetInfoEmployeeInShiftRow, error) {
	rows, err := q.db.Query(ctx, getInfoEmployeeInShift, arg.CompanyID, arg.ShiftID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInfoEmployeeInShiftRow
	for rows.Next() {
		var i GetInfoEmployeeInShiftRow
		if err := rows.Scan(
			&i.EmployeeID,
			&i.EmployeeCode,
			&i.FullName,
			&i.CurrentShift,
			&i.ShiftActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShiftByID = `-- name: GetShiftByID :one
SELECT shift_id, company_id, name, description, start_time, end_time, break_duration_minutes, grace_period_minutes, early_departure_minutes, work_days, is_flexible, overtime_after_minutes, is_active, created_at, updated_at
FROM work_shifts
WHERE shift_id = $1
`

func (q *Queries) GetShiftByID(ctx context.Context, shiftID pgtype.UUID) (WorkShift, error) {
	row := q.db.QueryRow(ctx, getShiftByID, shiftID)
	var i WorkShift
	err := row.Scan(
		&i.ShiftID,
		&i.CompanyID,
		&i.Name,
		&i.Description,
		&i.StartTime,
		&i.EndTime,
		&i.BreakDurationMinutes,
		&i.GracePeriodMinutes,
		&i.EarlyDepartureMinutes,
		&i.WorkDays,
		&i.IsFlexible,
		&i.OvertimeAfterMinutes,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getShiftsIdForCompany = `-- name: GetShiftsIdForCompany :many
SELECT shift_id
FROM work_shifts
WHERE company_id = $1
LIMIT $2 OFFSET $3
`

type GetShiftsIdForCompanyParams struct {
	CompanyID pgtype.UUID
	Limit     int32
	Offset    int32
}

func (q *Queries) GetShiftsIdForCompany(ctx context.Context, arg GetShiftsIdForCompanyParams) ([]pgtype.UUID, error) {
	rows, err := q.db.Query(ctx, getShiftsIdForCompany, arg.CompanyID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var shift_id pgtype.UUID
		if err := rows.Scan(&shift_id); err != nil {
			return nil, err
		}
		items = append(items, shift_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isUserManagetShift = `-- name: IsUserManagetShift :one

SELECT shift_id 
FROM work_shifts
WHERE shift_id = $1 AND company_id = $2
LIMIT 1
`

type IsUserManagetShiftParams struct {
	ShiftID   pgtype.UUID
	CompanyID pgtype.UUID
}

// CREATE TABLE IF NOT EXISTS work_shifts (
// shift_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
// company_id UUID NOT NULL REFERENCES companies(company_id) ON DELETE CASCADE,
// name VARCHAR(255) NOT NULL,
// description TEXT,
// start_time TIME NOT NULL,
// end_time TIME NOT NULL,
// break_duration_minutes INTEGER DEFAULT 0,
// grace_period_minutes INTEGER DEFAULT 15, -- Late arrival tolerance
// early_departure_minutes INTEGER DEFAULT 15, -- Early leave tolerance
// work_days INTEGER[] DEFAULT ARRAY[1,2,3,4,5], -- 1=Monday, 7=Sunday
// is_flexible BOOLEAN DEFAULT FALSE,
// overtime_after_minutes INTEGER DEFAULT 480, -- 8 hours = 480 minutes
// is_active BOOLEAN DEFAULT TRUE,
// created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
// updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
// )
func (q *Queries) IsUserManagetShift(ctx context.Context, arg IsUserManagetShiftParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, isUserManagetShift, arg.ShiftID, arg.CompanyID)
	var shift_id pgtype.UUID
	err := row.Scan(&shift_id)
	return shift_id, err
}

const listShifts = `-- name: ListShifts :many
SELECT shift_id, company_id, name, description, start_time, end_time, break_duration_minutes, grace_period_minutes, early_departure_minutes, work_days, is_flexible, overtime_after_minutes, is_active, created_at, updated_at
FROM work_shifts
WHERE company_id = $1
ORDER BY name
LIMIT $2 OFFSET $3
`

type ListShiftsParams struct {
	CompanyID pgtype.UUID
	Limit     int32
	Offset    int32
}

func (q *Queries) ListShifts(ctx context.Context, arg ListShiftsParams) ([]WorkShift, error) {
	rows, err := q.db.Query(ctx, listShifts, arg.CompanyID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WorkShift
	for rows.Next() {
		var i WorkShift
		if err := rows.Scan(
			&i.ShiftID,
			&i.CompanyID,
			&i.Name,
			&i.Description,
			&i.StartTime,
			&i.EndTime,
			&i.BreakDurationMinutes,
			&i.GracePeriodMinutes,
			&i.EarlyDepartureMinutes,
			&i.WorkDays,
			&i.IsFlexible,
			&i.OvertimeAfterMinutes,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTimeShift = `-- name: UpdateTimeShift :exec
UPDATE work_shifts
SET start_time = $2,
    end_time = $3,
    break_duration_minutes = $4,
    grace_period_minutes = $5,
    early_departure_minutes = $6,
    work_days = $7,
    updated_at = now()
WHERE shift_id = $1
`

type UpdateTimeShiftParams struct {
	ShiftID               pgtype.UUID
	StartTime             pgtype.Time
	EndTime               pgtype.Time
	BreakDurationMinutes  pgtype.Int4
	GracePeriodMinutes    pgtype.Int4
	EarlyDepartureMinutes pgtype.Int4
	WorkDays              []int32
}

func (q *Queries) UpdateTimeShift(ctx context.Context, arg UpdateTimeShiftParams) error {
	_, err := q.db.Exec(ctx, updateTimeShift,
		arg.ShiftID,
		arg.StartTime,
		arg.EndTime,
		arg.BreakDurationMinutes,
		arg.GracePeriodMinutes,
		arg.EarlyDepartureMinutes,
		arg.WorkDays,
	)
	return err
}
