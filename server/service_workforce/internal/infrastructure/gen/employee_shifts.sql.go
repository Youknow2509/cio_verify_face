// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: employee_shifts.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addShiftForEmployee = `-- name: AddShiftForEmployee :exec
INSERT INTO employee_shifts (
    employee_id,
    shift_id,
    effective_from,
    effective_to
) VALUES ($1, $2, $3, $4)
`

type AddShiftForEmployeeParams struct {
	EmployeeID    pgtype.UUID
	ShiftID       pgtype.UUID
	EffectiveFrom pgtype.Date
	EffectiveTo   pgtype.Date
}

func (q *Queries) AddShiftForEmployee(ctx context.Context, arg AddShiftForEmployeeParams) error {
	_, err := q.db.Exec(ctx, addShiftForEmployee,
		arg.EmployeeID,
		arg.ShiftID,
		arg.EffectiveFrom,
		arg.EffectiveTo,
	)
	return err
}

const checkUserExistShift = `-- name: CheckUserExistShift :one
SELECT employee_id,
    effective_from,
    effective_to
FROM employee_shifts
WHERE employee_id = $1 AND
    effective_from <= $2 AND
    effective_to >= $3 AND
    is_active = true
LIMIT $4 OFFSET $5
`

type CheckUserExistShiftParams struct {
	EmployeeID    pgtype.UUID
	EffectiveFrom pgtype.Date
	EffectiveTo   pgtype.Date
	Limit         int32
	Offset        int32
}

type CheckUserExistShiftRow struct {
	EmployeeID    pgtype.UUID
	EffectiveFrom pgtype.Date
	EffectiveTo   pgtype.Date
}

func (q *Queries) CheckUserExistShift(ctx context.Context, arg CheckUserExistShiftParams) (CheckUserExistShiftRow, error) {
	row := q.db.QueryRow(ctx, checkUserExistShift,
		arg.EmployeeID,
		arg.EffectiveFrom,
		arg.EffectiveTo,
		arg.Limit,
		arg.Offset,
	)
	var i CheckUserExistShiftRow
	err := row.Scan(&i.EmployeeID, &i.EffectiveFrom, &i.EffectiveTo)
	return i, err
}

const countEmployeesInShift = `-- name: CountEmployeesInShift :one

SELECT COUNT(DISTINCT employee_id) AS employee_count
FROM employee_shifts
WHERE shift_id = $1
`

// Table: employee_shifts
// employee_id UUID NOT NULL REFERENCES employees(employee_id) ON DELETE CASCADE,
// shift_id UUID NOT NULL REFERENCES work_shifts(shift_id) ON DELETE CASCADE,
// effective_from DATE NOT NULL,
// effective_to DATE,
// is_active BOOLEAN DEFAULT TRUE,
// created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
// UNIQUE(employee_id, shift_id, effective_from, effective_to)
func (q *Queries) CountEmployeesInShift(ctx context.Context, shiftID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countEmployeesInShift, shiftID)
	var employee_count int64
	err := row.Scan(&employee_count)
	return employee_count, err
}

const deleteEmployeeShift = `-- name: DeleteEmployeeShift :exec
DELETE FROM employee_shifts
WHERE employee_id = $1 and shift_id = $2
`

type DeleteEmployeeShiftParams struct {
	EmployeeID pgtype.UUID
	ShiftID    pgtype.UUID
}

func (q *Queries) DeleteEmployeeShift(ctx context.Context, arg DeleteEmployeeShiftParams) error {
	_, err := q.db.Exec(ctx, deleteEmployeeShift, arg.EmployeeID, arg.ShiftID)
	return err
}

const disableEmployeeShift = `-- name: DisableEmployeeShift :exec
UPDATE employee_shifts
SET is_active = false
WHERE employee_id = $1 and shift_id = $2
`

type DisableEmployeeShiftParams struct {
	EmployeeID pgtype.UUID
	ShiftID    pgtype.UUID
}

func (q *Queries) DisableEmployeeShift(ctx context.Context, arg DisableEmployeeShiftParams) error {
	_, err := q.db.Exec(ctx, disableEmployeeShift, arg.EmployeeID, arg.ShiftID)
	return err
}

const editEffectiveShiftForEmployee = `-- name: EditEffectiveShiftForEmployee :exec
UPDATE employee_shifts
SET effective_from = $2,
    effective_to = $3
WHERE employee_id = $1 and shift_id = $2
`

type EditEffectiveShiftForEmployeeParams struct {
	EmployeeID    pgtype.UUID
	EffectiveFrom pgtype.Date
	EffectiveTo   pgtype.Date
}

func (q *Queries) EditEffectiveShiftForEmployee(ctx context.Context, arg EditEffectiveShiftForEmployeeParams) error {
	_, err := q.db.Exec(ctx, editEffectiveShiftForEmployee, arg.EmployeeID, arg.EffectiveFrom, arg.EffectiveTo)
	return err
}

const enableEmployeeShift = `-- name: EnableEmployeeShift :exec
UPDATE employee_shifts
SET is_active = true
WHERE employee_id = $1 and shift_id = $2
`

type EnableEmployeeShiftParams struct {
	EmployeeID pgtype.UUID
	ShiftID    pgtype.UUID
}

func (q *Queries) EnableEmployeeShift(ctx context.Context, arg EnableEmployeeShiftParams) error {
	_, err := q.db.Exec(ctx, enableEmployeeShift, arg.EmployeeID, arg.ShiftID)
	return err
}

const getShiftEmployeeWithEffectiveDate = `-- name: GetShiftEmployeeWithEffectiveDate :many
SELECT 
    shift_id,
    effective_from,
    effective_to,
    is_active
FROM employee_shifts
WHERE employee_id = $1 AND
    effective_from <= $2 AND
    (effective_to IS NULL OR effective_to >= $2)
ORDER BY effective_from DESC
LIMIT $3 OFFSET $4
`

type GetShiftEmployeeWithEffectiveDateParams struct {
	EmployeeID    pgtype.UUID
	EffectiveFrom pgtype.Date
	Limit         int32
	Offset        int32
}

type GetShiftEmployeeWithEffectiveDateRow struct {
	ShiftID       pgtype.UUID
	EffectiveFrom pgtype.Date
	EffectiveTo   pgtype.Date
	IsActive      pgtype.Bool
}

func (q *Queries) GetShiftEmployeeWithEffectiveDate(ctx context.Context, arg GetShiftEmployeeWithEffectiveDateParams) ([]GetShiftEmployeeWithEffectiveDateRow, error) {
	rows, err := q.db.Query(ctx, getShiftEmployeeWithEffectiveDate,
		arg.EmployeeID,
		arg.EffectiveFrom,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetShiftEmployeeWithEffectiveDateRow
	for rows.Next() {
		var i GetShiftEmployeeWithEffectiveDateRow
		if err := rows.Scan(
			&i.ShiftID,
			&i.EffectiveFrom,
			&i.EffectiveTo,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
