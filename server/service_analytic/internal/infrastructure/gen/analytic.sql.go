// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: analytic.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAttendanceRecordsByDateRange = `-- name: GetAttendanceRecordsByDateRange :many
SELECT 
    record_id,
    employee_id,
    device_id,
    timestamp,
    record_type,
    verification_method,
    verification_score,
    face_image_url,
    sync_status,
    created_at
FROM attendance_records
WHERE employee_id = $1
AND timestamp >= $2
AND timestamp <= $3
ORDER BY timestamp
`

type GetAttendanceRecordsByDateRangeParams struct {
	EmployeeID  pgtype.UUID
	Timestamp   pgtype.Timestamptz
	Timestamp_2 pgtype.Timestamptz
}

type GetAttendanceRecordsByDateRangeRow struct {
	RecordID           pgtype.UUID
	EmployeeID         pgtype.UUID
	DeviceID           pgtype.UUID
	Timestamp          pgtype.Timestamptz
	RecordType         int32
	VerificationMethod pgtype.Text
	VerificationScore  pgtype.Numeric
	FaceImageUrl       pgtype.Text
	SyncStatus         pgtype.Int2
	CreatedAt          pgtype.Timestamptz
}

func (q *Queries) GetAttendanceRecordsByDateRange(ctx context.Context, arg GetAttendanceRecordsByDateRangeParams) ([]GetAttendanceRecordsByDateRangeRow, error) {
	rows, err := q.db.Query(ctx, getAttendanceRecordsByDateRange, arg.EmployeeID, arg.Timestamp, arg.Timestamp_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAttendanceRecordsByDateRangeRow
	for rows.Next() {
		var i GetAttendanceRecordsByDateRangeRow
		if err := rows.Scan(
			&i.RecordID,
			&i.EmployeeID,
			&i.DeviceID,
			&i.Timestamp,
			&i.RecordType,
			&i.VerificationMethod,
			&i.VerificationScore,
			&i.FaceImageUrl,
			&i.SyncStatus,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAttendanceSummaryByDateRange = `-- name: GetAttendanceSummaryByDateRange :many
SELECT 
    summary_id,
    employee_id,
    shift_id,
    work_date,
    scheduled_in,
    scheduled_out,
    actual_check_in,
    actual_check_out,
    total_work_minutes,
    break_minutes,
    overtime_minutes,
    late_minutes,
    early_leave_minutes,
    status,
    attendance_percentage,
    notes,
    approved_by,
    approved_at,
    created_at,
    updated_at
FROM daily_attendance_summary
WHERE work_date >= $1 AND work_date <= $2
AND ($3::uuid IS NULL OR employee_id IN (
    SELECT employee_id FROM employees WHERE company_id = $3
))
ORDER BY work_date, employee_id
`

type GetAttendanceSummaryByDateRangeParams struct {
	WorkDate   pgtype.Date
	WorkDate_2 pgtype.Date
	Column3    pgtype.UUID
}

func (q *Queries) GetAttendanceSummaryByDateRange(ctx context.Context, arg GetAttendanceSummaryByDateRangeParams) ([]DailyAttendanceSummary, error) {
	rows, err := q.db.Query(ctx, getAttendanceSummaryByDateRange, arg.WorkDate, arg.WorkDate_2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DailyAttendanceSummary
	for rows.Next() {
		var i DailyAttendanceSummary
		if err := rows.Scan(
			&i.SummaryID,
			&i.EmployeeID,
			&i.ShiftID,
			&i.WorkDate,
			&i.ScheduledIn,
			&i.ScheduledOut,
			&i.ActualCheckIn,
			&i.ActualCheckOut,
			&i.TotalWorkMinutes,
			&i.BreakMinutes,
			&i.OvertimeMinutes,
			&i.LateMinutes,
			&i.EarlyLeaveMinutes,
			&i.Status,
			&i.AttendancePercentage,
			&i.Notes,
			&i.ApprovedBy,
			&i.ApprovedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompanyByID = `-- name: GetCompanyByID :one
SELECT 
    company_id,
    name,
    address
FROM companies
WHERE company_id = $1
LIMIT 1
`

type GetCompanyByIDRow struct {
	CompanyID pgtype.UUID
	Name      string
	Address   pgtype.Text
}

func (q *Queries) GetCompanyByID(ctx context.Context, companyID pgtype.UUID) (GetCompanyByIDRow, error) {
	row := q.db.QueryRow(ctx, getCompanyByID, companyID)
	var i GetCompanyByIDRow
	err := row.Scan(&i.CompanyID, &i.Name, &i.Address)
	return i, err
}

const getDailyAttendanceSummaryByDate = `-- name: GetDailyAttendanceSummaryByDate :many
SELECT 
    summary_id,
    employee_id,
    shift_id,
    work_date,
    scheduled_in,
    scheduled_out,
    actual_check_in,
    actual_check_out,
    total_work_minutes,
    break_minutes,
    overtime_minutes,
    late_minutes,
    early_leave_minutes,
    status,
    attendance_percentage,
    notes,
    approved_by,
    approved_at,
    created_at,
    updated_at
FROM daily_attendance_summary
WHERE work_date = $1
AND ($2::uuid IS NULL OR employee_id IN (
    SELECT employee_id FROM employees WHERE company_id = $2
))
ORDER BY employee_id
`

type GetDailyAttendanceSummaryByDateParams struct {
	WorkDate pgtype.Date
	Column2  pgtype.UUID
}

func (q *Queries) GetDailyAttendanceSummaryByDate(ctx context.Context, arg GetDailyAttendanceSummaryByDateParams) ([]DailyAttendanceSummary, error) {
	rows, err := q.db.Query(ctx, getDailyAttendanceSummaryByDate, arg.WorkDate, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DailyAttendanceSummary
	for rows.Next() {
		var i DailyAttendanceSummary
		if err := rows.Scan(
			&i.SummaryID,
			&i.EmployeeID,
			&i.ShiftID,
			&i.WorkDate,
			&i.ScheduledIn,
			&i.ScheduledOut,
			&i.ActualCheckIn,
			&i.ActualCheckOut,
			&i.TotalWorkMinutes,
			&i.BreakMinutes,
			&i.OvertimeMinutes,
			&i.LateMinutes,
			&i.EarlyLeaveMinutes,
			&i.Status,
			&i.AttendancePercentage,
			&i.Notes,
			&i.ApprovedBy,
			&i.ApprovedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmployeeByID = `-- name: GetEmployeeByID :one
SELECT 
    employee_id,
    company_id,
    employee_code,
    department,
    position,
    hire_date,
    salary,
    status,
    created_at,
    updated_at
FROM employees
WHERE employee_id = $1
LIMIT 1
`

func (q *Queries) GetEmployeeByID(ctx context.Context, employeeID pgtype.UUID) (Employee, error) {
	row := q.db.QueryRow(ctx, getEmployeeByID, employeeID)
	var i Employee
	err := row.Scan(
		&i.EmployeeID,
		&i.CompanyID,
		&i.EmployeeCode,
		&i.Department,
		&i.Position,
		&i.HireDate,
		&i.Salary,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEmployeesByCompany = `-- name: GetEmployeesByCompany :many
SELECT 
    employee_id,
    company_id,
    employee_code,
    department,
    position,
    hire_date,
    salary,
    status,
    created_at,
    updated_at
FROM employees
WHERE company_id = $1
ORDER BY employee_code
`

func (q *Queries) GetEmployeesByCompany(ctx context.Context, companyID pgtype.UUID) ([]Employee, error) {
	rows, err := q.db.Query(ctx, getEmployeesByCompany, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Employee
	for rows.Next() {
		var i Employee
		if err := rows.Scan(
			&i.EmployeeID,
			&i.CompanyID,
			&i.EmployeeCode,
			&i.Department,
			&i.Position,
			&i.HireDate,
			&i.Salary,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalEmployeesCount = `-- name: GetTotalEmployeesCount :one
SELECT COUNT(*) as count
FROM employees
WHERE ($1::uuid IS NULL OR company_id = $1)
AND status = 0
`

func (q *Queries) GetTotalEmployeesCount(ctx context.Context, dollar_1 pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalEmployeesCount, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT 
    user_id,
    full_name,
    email,
    role
FROM users
WHERE user_id = $1
LIMIT 1
`

type GetUserByIDRow struct {
	UserID   pgtype.UUID
	FullName string
	Email    string
	Role     int16
}

func (q *Queries) GetUserByID(ctx context.Context, userID pgtype.UUID) (GetUserByIDRow, error) {
	row := q.db.QueryRow(ctx, getUserByID, userID)
	var i GetUserByIDRow
	err := row.Scan(
		&i.UserID,
		&i.FullName,
		&i.Email,
		&i.Role,
	)
	return i, err
}

const getWorkShiftByID = `-- name: GetWorkShiftByID :one
SELECT 
    shift_id,
    company_id,
    name,
    start_time::text as start_time,
    end_time::text as end_time
FROM work_shifts
WHERE shift_id = $1
LIMIT 1
`

type GetWorkShiftByIDRow struct {
	ShiftID   pgtype.UUID
	CompanyID pgtype.UUID
	Name      string
	StartTime string
	EndTime   string
}

func (q *Queries) GetWorkShiftByID(ctx context.Context, shiftID pgtype.UUID) (GetWorkShiftByIDRow, error) {
	row := q.db.QueryRow(ctx, getWorkShiftByID, shiftID)
	var i GetWorkShiftByIDRow
	err := row.Scan(
		&i.ShiftID,
		&i.CompanyID,
		&i.Name,
		&i.StartTime,
		&i.EndTime,
	)
	return i, err
}

const getWorkShiftsByCompany = `-- name: GetWorkShiftsByCompany :many
SELECT 
    shift_id,
    company_id,
    name,
    start_time::text as start_time,
    end_time::text as end_time
FROM work_shifts
WHERE company_id = $1
ORDER BY start_time
`

type GetWorkShiftsByCompanyRow struct {
	ShiftID   pgtype.UUID
	CompanyID pgtype.UUID
	Name      string
	StartTime string
	EndTime   string
}

func (q *Queries) GetWorkShiftsByCompany(ctx context.Context, companyID pgtype.UUID) ([]GetWorkShiftsByCompanyRow, error) {
	rows, err := q.db.Query(ctx, getWorkShiftsByCompany, companyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWorkShiftsByCompanyRow
	for rows.Next() {
		var i GetWorkShiftsByCompanyRow
		if err := rows.Scan(
			&i.ShiftID,
			&i.CompanyID,
			&i.Name,
			&i.StartTime,
			&i.EndTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
